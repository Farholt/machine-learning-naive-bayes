{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\r\n * @description a simple function that translates string label to integer based on index\r\n * @param obj\r\n */\nconst labelToInt = obj => {\n  let size = 0;\n  let tmp = {};\n\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      tmp[size] = obj[key];\n      delete obj[key];\n      size++;\n    }\n  }\n\n  return tmp;\n};\n/**\r\n *\r\n * @description this function helps figuring out which class a value belongs to\r\n * @param x\r\n * @param mean\r\n * @param stdev\r\n */\n\n\nconst probability = (x, mean, stdev) => {\n  let exponent = Math.exp(-(Math.pow(x - mean, 2) / (2 * Math.pow(stdev, 2))));\n  return 1 / (Math.sqrt(2 * Math.PI) * stdev) * exponent;\n};\n\nexport class NaiveBayes {\n  constructor() {\n    _defineProperty(this, \"obj\", void 0);\n\n    _defineProperty(this, \"label\", void 0);\n\n    _defineProperty(this, \"nOfAttributes\", void 0);\n\n    _defineProperty(this, \"group\", data => {\n      for (let i = 0; i < data.length; i++) {\n        let tmp = data[i][Object.keys(data[i])[Object.keys(data[i]).length - 1]]; // class name, e.g. Iris-setosa\n\n        if (!this.obj[tmp]) {\n          this.label.push([this.label.length]);\n          this.obj[tmp] = [];\n        }\n        /* Attributes of class */\n\n\n        let attributes = Object.keys(data[i]);\n        let type = attributes.pop(); // save and remove, e.g. \"species\" from object\n\n        if (data[i][type] === tmp) {\n          data[i][type] = this.label.length - 1;\n          this.obj[tmp].push(data[i]);\n        }\n      }\n      /* Rename labels to integer */\n\n\n      this.obj = labelToInt(this.obj);\n\n      for (let key in this.obj) {\n        if (this.obj.hasOwnProperty(key)) {\n          this.nOfAttributes = Object.keys(this.obj[key][0]).length;\n          console.log(this.nOfAttributes);\n        }\n      }\n      /* Push data and known labels to fit for training */\n\n\n      this.fit(this.obj, this.label);\n    });\n\n    _defineProperty(this, \"fit\", (X, y) => {\n      /* Go through each object and store as label */\n      for (let key in X) {\n        if (X.hasOwnProperty(key)) {\n          let labelKey = y[key];\n\n          if (labelKey == key) {\n            this.label[key] = [];\n            /* These are placeholders and are to be replaced by 'real' data through mean and stdev methods */\n\n            let meanArr = new Array(this.nOfAttributes).fill(0);\n            let stdvArr = new Array(this.nOfAttributes).fill(0);\n            /* Create new label */\n\n            this.label[key].push({\n              id: key,\n              data: X[key],\n              mean: meanArr,\n              stdev: stdvArr,\n              prob: 0\n            });\n          }\n        }\n      }\n      /* Calculate mean and standard deviation after we've created the labels */\n\n\n      this.mean();\n      this.stdev();\n    });\n\n    _defineProperty(this, \"mean\", () => {\n      /* Calculate mean by data in each label */\n      for (let i = 0; i < this.label.length; i++) {\n        let e = this.label[i][0]; // nested array, therefore [0]\n\n        let data = e.data;\n        /* Loop each data object */\n\n        for (let j = 0; j < data.length; j++) {\n          /* Sum each attribute */\n          let ii = 0;\n\n          for (let key in data[j]) {\n            if (data[j].hasOwnProperty(key)) {\n              let tmp = parseInt(data[j][key]);\n              e.mean[ii] += tmp;\n              ii++;\n            }\n          }\n        }\n\n        for (let j = 0; j < this.nOfAttributes; j++) {\n          e.mean[j] /= data.length;\n        }\n      }\n    });\n\n    _defineProperty(this, \"stdev\", () => {\n      /* Calculate standard deviation based on data in each label */\n      for (let i = 0; i < this.label.length; i++) {\n        let e = this.label[i][0]; // nested array, therefore [0]\n\n        let data = e.data;\n        /* Loop each data object */\n\n        for (let j = 0; j < data.length; j++) {\n          /* Calculate each attribute */\n          let ii = 0;\n\n          for (let key in data[j]) {\n            if (data[j].hasOwnProperty(key)) {\n              let tmp = parseInt(data[j][key]);\n              e.stdev[ii] += Math.pow(tmp - e.mean[ii], 2);\n              ii++;\n            }\n          }\n        }\n\n        for (let j = 0; j < this.nOfAttributes; j++) {\n          e.stdev[j] /= data.length - 1;\n          e.stdev[j] = Math.sqrt(e.stdev[j]);\n        }\n      }\n    });\n\n    _defineProperty(this, \"classification\", X => {\n      for (let i = 0; i < this.label.length; i++) {\n        let e = this.label[i][0];\n        let p = 0.0;\n        let j = 0;\n\n        for (let key in X) {\n          if (X.hasOwnProperty(key)) {\n            if (!isNaN(Math.log(probability(X[key], e.mean[j], e.stdev[j])))) {\n              p += Math.log(probability(X[key], e.mean[j], e.stdev[j]));\n            }\n\n            j++;\n          }\n        }\n\n        e.prob = Math.exp(p);\n      }\n\n      return this.bestLabel();\n    });\n\n    _defineProperty(this, \"bestLabel\", () => {\n      let max = 0;\n      let index = -1;\n\n      for (let i = 0; i < this.label.length; i++) {\n        let e = this.label[i][0];\n\n        if (e.prob > max || index == -1) {\n          max = this.label[i][0].prob;\n          index = i;\n        }\n      }\n\n      return this.label[index][0].id;\n    });\n\n    this.obj = {};\n    this.label = [];\n  }\n  /**\r\n   * @description this method seperates data based on class\r\n   * @param data\r\n   */\n\n\n  /**\r\n   * @description this method produces a list of predictions based on instances\r\n   * @param X\r\n   */\n  predict(X) {\n    let pred = [];\n\n    for (let i = 0; i < X.length; i++) {\n      let inst = X[i];\n      pred.push(this.classification(inst));\n    } // console.log(pred)\n\n\n    return pred;\n  }\n  /**\r\n   * @description this method classifies each instances\r\n   * @param X\r\n   */\n\n\n  accuracy_score() {\n    return null;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/fredr/Documents/Universitet/HT20/2DV515 - Web Intelligence/A4/shared/class/NaiveBayes.ts"],"names":["labelToInt","obj","size","tmp","key","hasOwnProperty","probability","x","mean","stdev","exponent","Math","exp","pow","sqrt","PI","NaiveBayes","constructor","data","i","length","Object","keys","label","push","attributes","type","pop","nOfAttributes","console","log","fit","X","y","labelKey","meanArr","Array","fill","stdvArr","id","prob","e","j","ii","parseInt","p","isNaN","bestLabel","max","index","predict","pred","inst","classification","accuracy_score"],"mappings":"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","sourcesContent":["import { indexOf } from 'list'\r\n\r\n/**\r\n * @description a simple function that translates string label to integer based on index\r\n * @param obj\r\n */\r\nconst labelToInt = (obj) => {\r\n  let size = 0\r\n  let tmp = {}\r\n\r\n  for (let key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      tmp[size] = obj[key]\r\n      delete obj[key]\r\n      size++\r\n    }\r\n  }\r\n\r\n  return tmp\r\n}\r\n\r\n/**\r\n *\r\n * @description this function helps figuring out which class a value belongs to\r\n * @param x\r\n * @param mean\r\n * @param stdev\r\n */\r\nconst probability = (x: number, mean: number, stdev: number) => {\r\n  let exponent = Math.exp(-(Math.pow(x - mean, 2) / (2 * Math.pow(stdev, 2))))\r\n  return (1 / (Math.sqrt(2 * Math.PI) * stdev)) * exponent\r\n}\r\n\r\nexport class NaiveBayes {\r\n  obj: Object\r\n  label: Array<any>\r\n  nOfAttributes: number\r\n\r\n  constructor() {\r\n    this.obj = {}\r\n    this.label = []\r\n  }\r\n\r\n  /**\r\n   * @description this method seperates data based on class\r\n   * @param data\r\n   */\r\n  group = (data: Array<string | number>) => {\r\n    for (let i = 0; i < data.length; i++) {\r\n      let tmp = data[i][Object.keys(data[i])[Object.keys(data[i]).length - 1]] // class name, e.g. Iris-setosa\r\n\r\n      if (!this.obj[tmp]) {\r\n        this.label.push([this.label.length])\r\n        this.obj[tmp] = []\r\n      }\r\n\r\n      /* Attributes of class */\r\n      let attributes = Object.keys(data[i])\r\n      let type = attributes.pop() // save and remove, e.g. \"species\" from object\r\n\r\n      if (data[i][type] === tmp) {\r\n        data[i][type] = this.label.length - 1\r\n        this.obj[tmp].push(data[i])\r\n      }\r\n    }\r\n\r\n    /* Rename labels to integer */\r\n    this.obj = labelToInt(this.obj)\r\n\r\n    for (let key in this.obj) {\r\n      if (this.obj.hasOwnProperty(key)) {\r\n        this.nOfAttributes = Object.keys(this.obj[key][0]).length\r\n        console.log(this.nOfAttributes)\r\n      }\r\n    }\r\n\r\n    /* Push data and known labels to fit for training */\r\n\r\n    this.fit(this.obj, this.label)\r\n  }\r\n\r\n  /**\r\n   * @description this method helps train the model\r\n   * @param x\r\n   * @param y\r\n   */\r\n  fit = (X: Object, y: Array<number>): void => {\r\n    /* Go through each object and store as label */\r\n    for (let key in X) {\r\n      if (X.hasOwnProperty(key)) {\r\n        let labelKey = y[key]\r\n\r\n        if (labelKey == key) {\r\n          this.label[key] = []\r\n\r\n          /* These are placeholders and are to be replaced by 'real' data through mean and stdev methods */\r\n          let meanArr = new Array(this.nOfAttributes).fill(0)\r\n          let stdvArr = new Array(this.nOfAttributes).fill(0)\r\n\r\n          /* Create new label */\r\n          this.label[key].push({\r\n            id: key,\r\n            data: X[key],\r\n            mean: meanArr,\r\n            stdev: stdvArr,\r\n            prob: 0\r\n          })\r\n        }\r\n      }\r\n    }\r\n\r\n    /* Calculate mean and standard deviation after we've created the labels */\r\n    this.mean()\r\n    this.stdev()\r\n  }\r\n\r\n  /**\r\n   * @description this calculates mean\r\n   */\r\n  mean = (): void => {\r\n    /* Calculate mean by data in each label */\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      let e = this.label[i][0] // nested array, therefore [0]\r\n      let data = e.data\r\n\r\n      /* Loop each data object */\r\n      for (let j = 0; j < data.length; j++) {\r\n        /* Sum each attribute */\r\n        let ii = 0\r\n        for (let key in data[j]) {\r\n          if (data[j].hasOwnProperty(key)) {\r\n            let tmp = parseInt(data[j][key])\r\n            e.mean[ii] += tmp\r\n            ii++\r\n          }\r\n        }\r\n      }\r\n      for (let j = 0; j < this.nOfAttributes; j++) {\r\n        e.mean[j] /= data.length\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description this calculates standard deviation\r\n   */\r\n  stdev = (): void => {\r\n    /* Calculate standard deviation based on data in each label */\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      let e = this.label[i][0] // nested array, therefore [0]\r\n      let data = e.data\r\n\r\n      /* Loop each data object */\r\n      for (let j = 0; j < data.length; j++) {\r\n        /* Calculate each attribute */\r\n        let ii = 0\r\n        for (let key in data[j]) {\r\n          if (data[j].hasOwnProperty(key)) {\r\n            let tmp = parseInt(data[j][key])\r\n            e.stdev[ii] += Math.pow(tmp - e.mean[ii], 2)\r\n            ii++\r\n          }\r\n        }\r\n      }\r\n      for (let j = 0; j < this.nOfAttributes; j++) {\r\n        e.stdev[j] /= data.length - 1\r\n        e.stdev[j] = Math.sqrt(e.stdev[j])\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @description this method produces a list of predictions based on instances\r\n   * @param X\r\n   */\r\n  predict(X: Array<number>) {\r\n    let pred = []\r\n\r\n    for (let i = 0; i < X.length; i++) {\r\n      let inst = X[i]\r\n      pred.push(this.classification(inst))\r\n    }\r\n\r\n    // console.log(pred)\r\n    return pred\r\n  }\r\n\r\n  /**\r\n   * @description this method classifies each instances\r\n   * @param X\r\n   */\r\n  classification = (X: Object) => {\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      let e = this.label[i][0]\r\n      let p: number = 0.0\r\n\r\n      let j = 0\r\n      for (let key in X) {\r\n        if (X.hasOwnProperty(key)) {\r\n          if (!isNaN(Math.log(probability(X[key], e.mean[j], e.stdev[j])))) {\r\n            p += Math.log(probability(X[key], e.mean[j], e.stdev[j]))\r\n          }\r\n          j++\r\n        }\r\n      }\r\n      e.prob = Math.exp(p)\r\n    }\r\n\r\n    return this.bestLabel()\r\n  }\r\n\r\n  /**\r\n   * @description this method returns the best suited label for an instance\r\n   */\r\n  bestLabel = () => {\r\n    let max: number = 0\r\n    let index: number = -1\r\n\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      let e = this.label[i][0]\r\n\r\n      if (e.prob > max || index == -1) {\r\n        max = this.label[i][0].prob\r\n        index = i\r\n      }\r\n    }\r\n\r\n    return this.label[index][0].id\r\n  }\r\n\r\n  accuracy_score(): number {\r\n    return null\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}