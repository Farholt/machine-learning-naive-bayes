{"ast":null,"code":"function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst labelToInt = obj => {\n  let size = 0;\n  let tmp = {};\n\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      tmp[size] = obj[key];\n      delete obj[key];\n      size++;\n    }\n  }\n\n  return tmp;\n};\n\nexport class NaiveBayes {\n  constructor() {\n    _defineProperty(this, \"obj\", void 0);\n\n    _defineProperty(this, \"label\", void 0);\n\n    _defineProperty(this, \"group\", data => {\n      for (let i = 0; i < data.length; i++) {\n        let tmp = data[i][Object.keys(data[i])[Object.keys(data[i]).length - 1]]; // class name, e.g. Iris-setosa\n\n        if (!this.obj[tmp]) {\n          this.label.push([this.label.length, tmp]);\n          this.obj[tmp] = [];\n        }\n        /* Attributes of class */\n\n\n        let attributes = Object.keys(data[i]);\n        let type = attributes.pop(); // save and remove, e.g. \"species\" from object\n\n        if (data[i][type] === tmp) {\n          data[i][type] = this.label.length - 1;\n          this.obj[tmp].push(data[i]);\n        }\n      }\n      /* Rename labels to integer */\n\n\n      this.obj = labelToInt(this.obj);\n      /* Push data and known labels to fit for training */\n\n      this.fit(this.obj, this.label);\n    });\n\n    _defineProperty(this, \"fit\", (X, y) => {\n      /* Go through each object and store as label */\n      for (let key in X) {\n        if (X.hasOwnProperty(key)) {\n          let labelKey = y[key][0];\n\n          if (labelKey == key) {\n            this.label[key] = [];\n            let emptyArr = new Array(X[key].length).fill(0);\n            this.label[key].push({\n              id: key,\n              data: X[key],\n              mean: emptyArr,\n              stdev: emptyArr,\n              prob: 0\n            });\n          }\n        }\n      }\n\n      for (let i = 0; i < this.label.length; i++) {\n        let e = this.label[i][0];\n        let data = e.data;\n\n        for (let ii = 0; ii < data.length; ii++) {\n          console.log(Object.keys(data).length.length);\n        }\n      }\n    });\n\n    this.obj = {};\n    this.label = [];\n  }\n  /**\r\n   * @description this method seperates data based on class\r\n   * @param data\r\n   */\n\n\n  predict() {\n    return null;\n  }\n\n  accuracy_score() {\n    return null;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/fredr/Documents/Universitet/HT20/2DV515 - Web Intelligence/A4/shared/class/NaiveBayes.ts"],"names":["labelToInt","obj","size","tmp","key","hasOwnProperty","NaiveBayes","constructor","data","i","length","Object","keys","label","push","attributes","type","pop","fit","X","y","labelKey","emptyArr","Array","fill","id","mean","stdev","prob","e","ii","console","log","predict","accuracy_score"],"mappings":"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","sourcesContent":["const labelToInt = (obj) => {\r\n  let size = 0\r\n  let tmp = {}\r\n\r\n  for (let key in obj) {\r\n    if (obj.hasOwnProperty(key)) {\r\n      tmp[size] = obj[key]\r\n      delete obj[key]\r\n      size++\r\n    }\r\n  }\r\n\r\n  return tmp\r\n}\r\n\r\nexport class NaiveBayes {\r\n  obj: Object\r\n  label: Array<any>\r\n\r\n  constructor() {\r\n    this.obj = {}\r\n    this.label = []\r\n  }\r\n\r\n  /**\r\n   * @description this method seperates data based on class\r\n   * @param data\r\n   */\r\n  group = (data: Array<string | number>) => {\r\n    for (let i = 0; i < data.length; i++) {\r\n      let tmp = data[i][Object.keys(data[i])[Object.keys(data[i]).length - 1]] // class name, e.g. Iris-setosa\r\n\r\n      if (!this.obj[tmp]) {\r\n        this.label.push([this.label.length, tmp])\r\n        this.obj[tmp] = []\r\n      }\r\n\r\n      /* Attributes of class */\r\n      let attributes = Object.keys(data[i])\r\n      let type = attributes.pop() // save and remove, e.g. \"species\" from object\r\n\r\n      if (data[i][type] === tmp) {\r\n        data[i][type] = this.label.length - 1\r\n        this.obj[tmp].push(data[i])\r\n      }\r\n    }\r\n\r\n    /* Rename labels to integer */\r\n    this.obj = labelToInt(this.obj)\r\n\r\n    /* Push data and known labels to fit for training */\r\n\r\n    this.fit(this.obj, this.label)\r\n  }\r\n\r\n  /**\r\n   * @description this method helps train the model\r\n   * @param x\r\n   * @param y\r\n   */\r\n  fit = (X: Object, y: Array<number>): void => {\r\n    /* Go through each object and store as label */\r\n    for (let key in X) {\r\n      if (X.hasOwnProperty(key)) {\r\n        let labelKey = y[key][0]\r\n        if (labelKey == key) {\r\n          this.label[key] = []\r\n\r\n          let emptyArr = new Array(X[key].length).fill(0)\r\n\r\n          this.label[key].push({\r\n            id: key,\r\n            data: X[key],\r\n            mean: emptyArr,\r\n            stdev: emptyArr,\r\n            prob: 0\r\n          })\r\n        }\r\n      }\r\n    }\r\n\r\n    for (let i = 0; i < this.label.length; i++) {\r\n      let e = this.label[i][0]\r\n      let data = e.data\r\n      for (let ii = 0; ii < data.length; ii++) {\r\n        console.log(Object.keys(data).length.length)\r\n      }\r\n    }\r\n  }\r\n\r\n  predict(): number {\r\n    return null\r\n  }\r\n\r\n  accuracy_score(): number {\r\n    return null\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}